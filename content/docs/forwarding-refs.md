---
id: forwarding-refs
title: Перенаправлення Рефів
permalink: docs/forwarding-refs.html
---

Перенаправлення рефів — це техніка для автоматичної передачі [рефа](/docs/refs-and-the-dom.html) від компонента до одного із його дітей. Зазвичай, не є необхідною для більшості компонентів додатку. Тим не менше, може бути корисним в деяких випадках, особливо в перевикористовуваних компонентах бібліотек. Найбільш поширені сценарії є описані внизу.

## Перенаправлення рефів в DOM-компоненти {#forwarding-refs-to-dom-components}

Розглянемо компонент `FancyButton`, який рендерить нативний DOM-елемент `button`:

`embed:forwarding-refs/fancy-button-simple.js`

React-компоненти приховують деталі своєї реалізації та результат рендеренгу. Також іншим компонентам, які використовують `FancyButton`, **зазвичай не потрібно** [доступатись до рефа](/docs/refs-and-the-dom.html) його внутрішнього DOM-елемента `button`. 
І це добре тим, що запобігає надмірній залежності компонентів від структури DOM-у один одного.

Хоча, така енкапсуляції є бажаною для компонентів, які описують певну закінчену частину додатка, наприклад, `FeedStory` або `Comment`, це може бути незручним для часто перевикористовуваних "дрібних" компонентів, таких як `FancyButton` та `MyTextInput`. Ці компоненти використовуються в додатку подібно як звичайний DOM `button` чи `input` і доступ до їхніх DOM-вузлів може бути необхідним для управління фокусом, виділенням або анімацією.

**Перенаправлення рефів дає можливість певному компоненту взяти отриманий реф і передати його далі (іншими словами "перенаправити") до дочірнього компоненту.**

На прикладі нижче, `FancyButton` використовує `React.forwardRef`, щоб отримати переданий йому `ref` і перенаправити його в DOM `button`, який він рендерить:

`embed:forwarding-refs/fancy-button-simple-ref.js`

Таким чином, компоненти, що використовують `FancyButton` можуть отримати реф внутрішнього DOM-вузла `button` і якщо потрібно, доступатись до DOM `button` подібно до того, якби він використовувався напряму.

Тут покроково пояснено, що відбувається в прикладі вище:

1. Ми створюємо [React реф](/docs/refs-and-the-dom.html), викликаючи `React.createRef` і записуєм його в змінну `ref`.
1. Ми передаємо наш `ref` в `<FancyButton ref={ref}>`, вказуючи його як JSX-атрибут.
1. React передає `ref` в функцію `(props, ref) => ...` всередині `forwardRef` другим аргументом.
1. Ми перенаправляєм аргумент `ref` дальше до `<button ref={ref}>`, вказуючи його як JSX-атрибут.
1. Після привязки рефа, `ref.current` буде вказувати на DOM-вузол `<button>`.

>Примітка
>
>Другий аргумент `ref` існує тільки тоді, коли ви визачаєте комонент викликом функції `React.forwardRef`. Звичайні функціональні або класові компоненти не отримують `ref` в якості аргумента чи пропси.
>
>Перенаправлення рефів не обмежуються DOM-компонентами. Ви також можете перенапарвити реф в екземпляр класового компонента.

## Замітка для розробників бібліотеки компонентів {#note-for-component-library-maintainers}

**Коли ви починаєте використовувати `forwardRef` в бібліотеці компонентів, ви повинні вважати це як несумісну зміну і випустити нову мажорну версію.** Це тому, що ваша бібліотека, скоріше за все, буде мати замітно іншу поведінку (такі як: те, на що вказує реф; які типи експортуються), в результаті може поламатись додаток або інші бібліотеки, що залежать від старої поведінки.

Також, по тій же причині, не рекомендується застосовувати `React.forwardRef` умовно, з перевіркою чи функція існує. Оскільки це міняє те, як ваша бібліотека буде поводитись, після того, як користувач бібліотеки обновить версію React.

## Перенаправлення рефів в компонентах вищого порядку {#forwarding-refs-in-higher-order-components}

Ця техніка також може бути особливо корисною в [компонентах вищого порядку](/docs/higher-order-components.html) (ще відомі, як КВП). Давайте почнемо з прикладу КВП, який виводить логи компонента в консоль:
`embed:forwarding-refs/log-props-before.js`

КВП "logProps" передає всі `props` до компонента, якого він обгортає, такщо результат рендеру буде такий самий. Наприклад, ми можемо використати цей КВП, щоб вивести всі пропси передані в наш компонент `FancyButton`:
`embed:forwarding-refs/fancy-button.js`

Є одне застереження щодо прикладу вище: тут рефи не будуть передаватись. Це тому, що `ref` не є пропом. Подібно до `key`, React опрацьовує `ref` по-іншому. Якщо ви добавити реф до КВП, реф буде вказувати на зовнішній компонент-контейнер, а не на обгорнутий компонент.

Це означає, що рефи призначені для компонента `FancyButton` насправді будуть привязані до компонента `LogProps`:
`embed:forwarding-refs/fancy-button-ref.js`

Нащастя, ми можем явно перенаправити реф до внутрішнього компонента `FancyButton` використовуючи `React.forwardRef` API. `React.forwardRef` приймає рендер функцію, яка отримує параметри `props` і `ref` та повертає React-вузол. Наприклад:
`embed:forwarding-refs/log-props-after.js`

## Відображення іншого імені в DevTools {#displaying-a-custom-name-in-devtools}

`React.forwardRef` отримує рендер фукнцію. React DevTools використовує цю функцію, щоб визначити, як відображати компонент перенаправлення рефа.

Наприклад, наступний компонент буде відображатись в DevTools, як "*ForwardRef*":

`embed:forwarding-refs/wrapped-component.js`

Якщо ви називаєте рендер функцію, DevTools відобразить також її ім'я ("*ForwardRef(myFunction)*"):

`embed:forwarding-refs/wrapped-component-with-function-name.js`

Ви можете навіть визначити функції властивість `displayName` і вказати в ньому, який компонент є обгорнутий.

`embed:forwarding-refs/customized-display-name.js`
